# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pagination import AsyncPager, BaseHttpResponse, SyncPager
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from ..requests.catalog_object_batch import CatalogObjectBatchParams
from ..requests.catalog_query import CatalogQueryParams
from ..requests.custom_attribute_filter import CustomAttributeFilterParams
from ..types.archived_state import ArchivedState
from ..types.batch_delete_catalog_objects_response import BatchDeleteCatalogObjectsResponse
from ..types.batch_get_catalog_objects_response import BatchGetCatalogObjectsResponse
from ..types.batch_upsert_catalog_objects_response import BatchUpsertCatalogObjectsResponse
from ..types.catalog_info_response import CatalogInfoResponse
from ..types.catalog_item_product_type import CatalogItemProductType
from ..types.catalog_object import CatalogObject
from ..types.catalog_object_type import CatalogObjectType
from ..types.list_catalog_response import ListCatalogResponse
from ..types.search_catalog_items_request_stock_level import SearchCatalogItemsRequestStockLevel
from ..types.search_catalog_items_response import SearchCatalogItemsResponse
from ..types.search_catalog_objects_response import SearchCatalogObjectsResponse
from ..types.sort_order import SortOrder
from ..types.update_item_modifier_lists_response import UpdateItemModifierListsResponse
from ..types.update_item_taxes_response import UpdateItemTaxesResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawCatalogClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def batch_delete(
        self, *, object_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[BatchDeleteCatalogObjectsResponse]:
        """
        Deletes a set of [CatalogItem](entity:CatalogItem)s based on the
        provided list of target IDs and returns a set of successfully deleted IDs in
        the response. Deletion is a cascading event such that all children of the
        targeted object are also deleted. For example, deleting a CatalogItem will
        also delete all of its [CatalogItemVariation](entity:CatalogItemVariation)
        children.

        `BatchDeleteCatalogObjects` succeeds even if only a portion of the targeted
        IDs can be deleted. The response will only include IDs that were
        actually deleted.

        To ensure consistency, only one delete request is processed at a time per seller account.
        While one (batch or non-batch) delete request is being processed, other (batched and non-batched)
        delete requests are rejected with the `429` error code.

        Parameters
        ----------
        object_ids : typing.Sequence[str]
            The IDs of the CatalogObjects to be deleted. When an object is deleted, other objects
            in the graph that depend on that object will be deleted as well (for example, deleting a
            CatalogItem will delete its CatalogItemVariation.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchDeleteCatalogObjectsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/batch-delete",
            method="POST",
            json={
                "object_ids": object_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchDeleteCatalogObjectsResponse,
                    construct_type(
                        type_=BatchDeleteCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_get(
        self,
        *,
        object_ids: typing.Sequence[str],
        include_related_objects: typing.Optional[bool] = OMIT,
        catalog_version: typing.Optional[int] = OMIT,
        include_deleted_objects: typing.Optional[bool] = OMIT,
        include_category_path_to_root: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchGetCatalogObjectsResponse]:
        """
        Returns a set of objects based on the provided ID.
        Each [CatalogItem](entity:CatalogItem) returned in the set includes all of its
        child information including: all of its
        [CatalogItemVariation](entity:CatalogItemVariation) objects, references to
        its [CatalogModifierList](entity:CatalogModifierList) objects, and the ids of
        any [CatalogTax](entity:CatalogTax) objects that apply to it.

        Parameters
        ----------
        object_ids : typing.Sequence[str]
            The IDs of the CatalogObjects to be retrieved.

        include_related_objects : typing.Optional[bool]
            If `true`, the response will include additional objects that are related to the
            requested objects. Related objects are defined as any objects referenced by ID by the results in the `objects` field
            of the response. These objects are put in the `related_objects` field. Setting this to `true` is
            helpful when the objects are needed for immediate display to a user.
            This process only goes one level deep. Objects referenced by the related objects will not be included. For example,

            if the `objects` field of the response contains a CatalogItem, its associated
            CatalogCategory objects, CatalogTax objects, CatalogImage objects and
            CatalogModifierLists will be returned in the `related_objects` field of the
            response. If the `objects` field of the response contains a CatalogItemVariation,
            its parent CatalogItem will be returned in the `related_objects` field of
            the response.

            Default value: `false`

        catalog_version : typing.Optional[int]
            The specific version of the catalog objects to be included in the response.
            This allows you to retrieve historical versions of objects. The specified version value is matched against
            the [CatalogObject](entity:CatalogObject)s' `version` attribute. If not included, results will
            be from the current version of the catalog.

        include_deleted_objects : typing.Optional[bool]
            Indicates whether to include (`true`) or not (`false`) in the response deleted objects, namely, those with the `is_deleted` attribute set to `true`.

        include_category_path_to_root : typing.Optional[bool]
            Specifies whether or not to include the `path_to_root` list for each returned category instance. The `path_to_root` list consists
            of `CategoryPathToRootNode` objects and specifies the path that starts with the immediate parent category of the returned category
            and ends with its root category. If the returned category is a top-level category, the `path_to_root` list is empty and is not returned
            in the response payload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchGetCatalogObjectsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/batch-retrieve",
            method="POST",
            json={
                "object_ids": object_ids,
                "include_related_objects": include_related_objects,
                "catalog_version": catalog_version,
                "include_deleted_objects": include_deleted_objects,
                "include_category_path_to_root": include_category_path_to_root,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchGetCatalogObjectsResponse,
                    construct_type(
                        type_=BatchGetCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def batch_upsert(
        self,
        *,
        idempotency_key: str,
        batches: typing.Sequence[CatalogObjectBatchParams],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchUpsertCatalogObjectsResponse]:
        """
        Creates or updates up to 10,000 target objects based on the provided
        list of objects. The target objects are grouped into batches and each batch is
        inserted/updated in an all-or-nothing manner. If an object within a batch is
        malformed in some way, or violates a database constraint, the entire batch
        containing that item will be disregarded. However, other batches in the same
        request may still succeed. Each batch may contain up to 1,000 objects, and
        batches will be processed in order as long as the total object count for the
        request (items, variations, modifier lists, discounts, and taxes) is no more
        than 10,000.

        To ensure consistency, only one update request is processed at a time per seller account.
        While one (batch or non-batch) update request is being processed, other (batched and non-batched)
        update requests are rejected with the `429` error code.

        Parameters
        ----------
        idempotency_key : str
            A value you specify that uniquely identifies this
            request among all your requests. A common way to create
            a valid idempotency key is to use a Universally unique
            identifier (UUID).

            If you're unsure whether a particular request was successful,
            you can reattempt it with the same idempotency key without
            worrying about creating duplicate objects.

            See [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) for more information.

        batches : typing.Sequence[CatalogObjectBatchParams]
            A batch of CatalogObjects to be inserted/updated atomically.
            The objects within a batch will be inserted in an all-or-nothing fashion, i.e., if an error occurs
            attempting to insert or update an object within a batch, the entire batch will be rejected. However, an error
            in one batch will not affect other batches within the same request.

            For each object, its `updated_at` field is ignored and replaced with a current [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates), and its
            `is_deleted` field must not be set to `true`.

            To modify an existing object, supply its ID. To create a new object, use an ID starting
            with `#`. These IDs may be used to create relationships between an object and attributes of
            other objects that reference it. For example, you can create a CatalogItem with
            ID `#ABC` and a CatalogItemVariation with its `item_id` attribute set to
            `#ABC` in order to associate the CatalogItemVariation with its parent
            CatalogItem.

            Any `#`-prefixed IDs are valid only within a single atomic batch, and will be replaced by server-generated IDs.

            Each batch may contain up to 1,000 objects. The total number of objects across all batches for a single request
            may not exceed 10,000. If either of these limits is violated, an error will be returned and no objects will
            be inserted or updated.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchUpsertCatalogObjectsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/batch-upsert",
            method="POST",
            json={
                "idempotency_key": idempotency_key,
                "batches": convert_and_respect_annotation_metadata(
                    object_=batches, annotation=typing.Sequence[CatalogObjectBatchParams], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUpsertCatalogObjectsResponse,
                    construct_type(
                        type_=BatchUpsertCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def info(self, *, request_options: typing.Optional[RequestOptions] = None) -> HttpResponse[CatalogInfoResponse]:
        """
        Retrieves information about the Square Catalog API, such as batch size
        limits that can be used by the `BatchUpsertCatalogObjects` endpoint.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CatalogInfoResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogInfoResponse,
                    construct_type(
                        type_=CatalogInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def list(
        self,
        *,
        cursor: typing.Optional[str] = None,
        types: typing.Optional[str] = None,
        catalog_version: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[CatalogObject]:
        """
        Returns a list of all [CatalogObject](entity:CatalogObject)s of the specified types in the catalog.

        The `types` parameter is specified as a comma-separated list of the [CatalogObjectType](entity:CatalogObjectType) values,
        for example, "`ITEM`, `ITEM_VARIATION`, `MODIFIER`, `MODIFIER_LIST`, `CATEGORY`, `DISCOUNT`, `TAX`, `IMAGE`".

        __Important:__ ListCatalog does not return deleted catalog items. To retrieve
        deleted catalog items, use [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects)
        and set the `include_deleted_objects` attribute value to `true`.

        Parameters
        ----------
        cursor : typing.Optional[str]
            The pagination cursor returned in the previous response. Leave unset for an initial request.
            The page size is currently set to be 100.
            See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.

        types : typing.Optional[str]
            An optional case-insensitive, comma-separated list of object types to retrieve.

            The valid values are defined in the [CatalogObjectType](entity:CatalogObjectType) enum, for example,
            `ITEM`, `ITEM_VARIATION`, `CATEGORY`, `DISCOUNT`, `TAX`,
            `MODIFIER`, `MODIFIER_LIST`, `IMAGE`, etc.

            If this is unspecified, the operation returns objects of all the top level types at the version
            of the Square API used to make the request. Object types that are nested onto other object types
            are not included in the defaults.

            At the current API version the default object types are:
            ITEM, CATEGORY, TAX, DISCOUNT, MODIFIER_LIST,
            PRICING_RULE, PRODUCT_SET, TIME_PERIOD, MEASUREMENT_UNIT,
            SUBSCRIPTION_PLAN, ITEM_OPTION, CUSTOM_ATTRIBUTE_DEFINITION, QUICK_AMOUNT_SETTINGS.

        catalog_version : typing.Optional[int]
            The specific version of the catalog objects to be included in the response.
            This allows you to retrieve historical versions of objects. The specified version value is matched against
            the [CatalogObject](entity:CatalogObject)s' `version` attribute.  If not included, results will be from the
            current version of the catalog.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[CatalogObject]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/list",
            method="GET",
            params={
                "cursor": cursor,
                "types": types,
                "catalog_version": catalog_version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListCatalogResponse,
                    construct_type(
                        type_=ListCatalogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.objects
                _parsed_next = _parsed_response.cursor
                _has_next = _parsed_next is not None and _parsed_next != ""
                _get_next = lambda: self.list(
                    cursor=_parsed_next,
                    types=types,
                    catalog_version=catalog_version,
                    request_options=request_options,
                )
                return SyncPager(
                    has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search(
        self,
        *,
        cursor: typing.Optional[str] = OMIT,
        object_types: typing.Optional[typing.Sequence[CatalogObjectType]] = OMIT,
        include_deleted_objects: typing.Optional[bool] = OMIT,
        include_related_objects: typing.Optional[bool] = OMIT,
        begin_time: typing.Optional[str] = OMIT,
        query: typing.Optional[CatalogQueryParams] = OMIT,
        limit: typing.Optional[int] = OMIT,
        include_category_path_to_root: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SearchCatalogObjectsResponse]:
        """
        Searches for [CatalogObject](entity:CatalogObject) of any type by matching supported search attribute values,
        excluding custom attribute values on items or item variations, against one or more of the specified query filters.

        This (`SearchCatalogObjects`) endpoint differs from the [SearchCatalogItems](api-endpoint:Catalog-SearchCatalogItems)
        endpoint in the following aspects:

        - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects.
        - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not.
        - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does.
        - The both endpoints have different call conventions, including the query filter formats.

        Parameters
        ----------
        cursor : typing.Optional[str]
            The pagination cursor returned in the previous response. Leave unset for an initial request.
            See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.

        object_types : typing.Optional[typing.Sequence[CatalogObjectType]]
            The desired set of object types to appear in the search results.

            If this is unspecified, the operation returns objects of all the top level types at the version
            of the Square API used to make the request. Object types that are nested onto other object types
            are not included in the defaults.

            At the current API version the default object types are:
            ITEM, CATEGORY, TAX, DISCOUNT, MODIFIER_LIST,
            PRICING_RULE, PRODUCT_SET, TIME_PERIOD, MEASUREMENT_UNIT,
            SUBSCRIPTION_PLAN, ITEM_OPTION, CUSTOM_ATTRIBUTE_DEFINITION, QUICK_AMOUNT_SETTINGS.

            Note that if you wish for the query to return objects belonging to nested types (i.e., COMPONENT, IMAGE,
            ITEM_OPTION_VAL, ITEM_VARIATION, or MODIFIER), you must explicitly include all the types of interest
            in this field.

        include_deleted_objects : typing.Optional[bool]
            If `true`, deleted objects will be included in the results. Defaults to `false`. Deleted objects will have their `is_deleted` field set to `true`. If `include_deleted_objects` is `true`, then the `include_category_path_to_root` request parameter must be `false`. Both properties cannot be `true` at the same time.

        include_related_objects : typing.Optional[bool]
            If `true`, the response will include additional objects that are related to the
            requested objects. Related objects are objects that are referenced by object ID by the objects
            in the response. This is helpful if the objects are being fetched for immediate display to a user.
            This process only goes one level deep. Objects referenced by the related objects will not be included.
            For example:

            If the `objects` field of the response contains a CatalogItem, its associated
            CatalogCategory objects, CatalogTax objects, CatalogImage objects and
            CatalogModifierLists will be returned in the `related_objects` field of the
            response. If the `objects` field of the response contains a CatalogItemVariation,
            its parent CatalogItem will be returned in the `related_objects` field of
            the response.

            Default value: `false`

        begin_time : typing.Optional[str]
            Return objects modified after this [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates), in RFC 3339
            format, e.g., `2016-09-04T23:59:33.123Z`. The timestamp is exclusive - objects with a
            timestamp equal to `begin_time` will not be included in the response.

        query : typing.Optional[CatalogQueryParams]
            A query to be used to filter or sort the results. If no query is specified, the entire catalog will be returned.

        limit : typing.Optional[int]
            A limit on the number of results to be returned in a single page. The limit is advisory -
            the implementation may return more or fewer results. If the supplied limit is negative, zero, or
            is higher than the maximum limit of 1,000, it will be ignored.

        include_category_path_to_root : typing.Optional[bool]
            Specifies whether or not to include the `path_to_root` list for each returned category instance. The `path_to_root` list consists of `CategoryPathToRootNode` objects and specifies the path that starts with the immediate parent category of the returned category and ends with its root category. If the returned category is a top-level category, the `path_to_root` list is empty and is not returned in the response payload. If `include_category_path_to_root` is `true`, then the `include_deleted_objects` request parameter must be `false`. Both properties cannot be `true` at the same time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SearchCatalogObjectsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/search",
            method="POST",
            json={
                "cursor": cursor,
                "object_types": object_types,
                "include_deleted_objects": include_deleted_objects,
                "include_related_objects": include_related_objects,
                "begin_time": begin_time,
                "query": convert_and_respect_annotation_metadata(
                    object_=query, annotation=CatalogQueryParams, direction="write"
                ),
                "limit": limit,
                "include_category_path_to_root": include_category_path_to_root,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchCatalogObjectsResponse,
                    construct_type(
                        type_=SearchCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def search_items(
        self,
        *,
        text_filter: typing.Optional[str] = OMIT,
        category_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        stock_levels: typing.Optional[typing.Sequence[SearchCatalogItemsRequestStockLevel]] = OMIT,
        enabled_location_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        cursor: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        sort_order: typing.Optional[SortOrder] = OMIT,
        product_types: typing.Optional[typing.Sequence[CatalogItemProductType]] = OMIT,
        custom_attribute_filters: typing.Optional[typing.Sequence[CustomAttributeFilterParams]] = OMIT,
        archived_state: typing.Optional[ArchivedState] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SearchCatalogItemsResponse]:
        """
        Searches for catalog items or item variations by matching supported search attribute values, including
        custom attribute values, against one or more of the specified query filters.

        This (`SearchCatalogItems`) endpoint differs from the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects)
        endpoint in the following aspects:

        - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects.
        - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not.
        - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does.
        - The both endpoints use different call conventions, including the query filter formats.

        Parameters
        ----------
        text_filter : typing.Optional[str]
            The text filter expression to return items or item variations containing specified text in
            the `name`, `description`, or `abbreviation` attribute value of an item, or in
            the `name`, `sku`, or `upc` attribute value of an item variation.

        category_ids : typing.Optional[typing.Sequence[str]]
            The category id query expression to return items containing the specified category IDs.

        stock_levels : typing.Optional[typing.Sequence[SearchCatalogItemsRequestStockLevel]]
            The stock-level query expression to return item variations with the specified stock levels.
            See [SearchCatalogItemsRequestStockLevel](#type-searchcatalogitemsrequeststocklevel) for possible values

        enabled_location_ids : typing.Optional[typing.Sequence[str]]
            The enabled-location query expression to return items and item variations having specified enabled locations.

        cursor : typing.Optional[str]
            The pagination token, returned in the previous response, used to fetch the next batch of pending results.

        limit : typing.Optional[int]
            The maximum number of results to return per page. The default value is 100.

        sort_order : typing.Optional[SortOrder]
            The order to sort the results by item names. The default sort order is ascending (`ASC`).
            See [SortOrder](#type-sortorder) for possible values

        product_types : typing.Optional[typing.Sequence[CatalogItemProductType]]
            The product types query expression to return items or item variations having the specified product types.

        custom_attribute_filters : typing.Optional[typing.Sequence[CustomAttributeFilterParams]]
            The customer-attribute filter to return items or item variations matching the specified
            custom attribute expressions. A maximum number of 10 custom attribute expressions are supported in
            a single call to the [SearchCatalogItems](api-endpoint:Catalog-SearchCatalogItems) endpoint.

        archived_state : typing.Optional[ArchivedState]
            The query filter to return not archived (`ARCHIVED_STATE_NOT_ARCHIVED`), archived (`ARCHIVED_STATE_ARCHIVED`), or either type (`ARCHIVED_STATE_ALL`) of items.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SearchCatalogItemsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/search-catalog-items",
            method="POST",
            json={
                "text_filter": text_filter,
                "category_ids": category_ids,
                "stock_levels": stock_levels,
                "enabled_location_ids": enabled_location_ids,
                "cursor": cursor,
                "limit": limit,
                "sort_order": sort_order,
                "product_types": product_types,
                "custom_attribute_filters": convert_and_respect_annotation_metadata(
                    object_=custom_attribute_filters,
                    annotation=typing.Sequence[CustomAttributeFilterParams],
                    direction="write",
                ),
                "archived_state": archived_state,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchCatalogItemsResponse,
                    construct_type(
                        type_=SearchCatalogItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_item_modifier_lists(
        self,
        *,
        item_ids: typing.Sequence[str],
        modifier_lists_to_enable: typing.Optional[typing.Sequence[str]] = OMIT,
        modifier_lists_to_disable: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateItemModifierListsResponse]:
        """
        Updates the [CatalogModifierList](entity:CatalogModifierList) objects
        that apply to the targeted [CatalogItem](entity:CatalogItem) without having
        to perform an upsert on the entire item.

        Parameters
        ----------
        item_ids : typing.Sequence[str]
            The IDs of the catalog items associated with the CatalogModifierList objects being updated.

        modifier_lists_to_enable : typing.Optional[typing.Sequence[str]]
            The IDs of the CatalogModifierList objects to enable for the CatalogItem.
            At least one of `modifier_lists_to_enable` or `modifier_lists_to_disable` must be specified.

        modifier_lists_to_disable : typing.Optional[typing.Sequence[str]]
            The IDs of the CatalogModifierList objects to disable for the CatalogItem.
            At least one of `modifier_lists_to_enable` or `modifier_lists_to_disable` must be specified.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateItemModifierListsResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/update-item-modifier-lists",
            method="POST",
            json={
                "item_ids": item_ids,
                "modifier_lists_to_enable": modifier_lists_to_enable,
                "modifier_lists_to_disable": modifier_lists_to_disable,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateItemModifierListsResponse,
                    construct_type(
                        type_=UpdateItemModifierListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def update_item_taxes(
        self,
        *,
        item_ids: typing.Sequence[str],
        taxes_to_enable: typing.Optional[typing.Sequence[str]] = OMIT,
        taxes_to_disable: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateItemTaxesResponse]:
        """
        Updates the [CatalogTax](entity:CatalogTax) objects that apply to the
        targeted [CatalogItem](entity:CatalogItem) without having to perform an
        upsert on the entire item.

        Parameters
        ----------
        item_ids : typing.Sequence[str]
            IDs for the CatalogItems associated with the CatalogTax objects being updated.
            No more than 1,000 IDs may be provided.

        taxes_to_enable : typing.Optional[typing.Sequence[str]]
            IDs of the CatalogTax objects to enable.
            At least one of `taxes_to_enable` or `taxes_to_disable` must be specified.

        taxes_to_disable : typing.Optional[typing.Sequence[str]]
            IDs of the CatalogTax objects to disable.
            At least one of `taxes_to_enable` or `taxes_to_disable` must be specified.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateItemTaxesResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/catalog/update-item-taxes",
            method="POST",
            json={
                "item_ids": item_ids,
                "taxes_to_enable": taxes_to_enable,
                "taxes_to_disable": taxes_to_disable,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateItemTaxesResponse,
                    construct_type(
                        type_=UpdateItemTaxesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawCatalogClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def batch_delete(
        self, *, object_ids: typing.Sequence[str], request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[BatchDeleteCatalogObjectsResponse]:
        """
        Deletes a set of [CatalogItem](entity:CatalogItem)s based on the
        provided list of target IDs and returns a set of successfully deleted IDs in
        the response. Deletion is a cascading event such that all children of the
        targeted object are also deleted. For example, deleting a CatalogItem will
        also delete all of its [CatalogItemVariation](entity:CatalogItemVariation)
        children.

        `BatchDeleteCatalogObjects` succeeds even if only a portion of the targeted
        IDs can be deleted. The response will only include IDs that were
        actually deleted.

        To ensure consistency, only one delete request is processed at a time per seller account.
        While one (batch or non-batch) delete request is being processed, other (batched and non-batched)
        delete requests are rejected with the `429` error code.

        Parameters
        ----------
        object_ids : typing.Sequence[str]
            The IDs of the CatalogObjects to be deleted. When an object is deleted, other objects
            in the graph that depend on that object will be deleted as well (for example, deleting a
            CatalogItem will delete its CatalogItemVariation.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchDeleteCatalogObjectsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/batch-delete",
            method="POST",
            json={
                "object_ids": object_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchDeleteCatalogObjectsResponse,
                    construct_type(
                        type_=BatchDeleteCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_get(
        self,
        *,
        object_ids: typing.Sequence[str],
        include_related_objects: typing.Optional[bool] = OMIT,
        catalog_version: typing.Optional[int] = OMIT,
        include_deleted_objects: typing.Optional[bool] = OMIT,
        include_category_path_to_root: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchGetCatalogObjectsResponse]:
        """
        Returns a set of objects based on the provided ID.
        Each [CatalogItem](entity:CatalogItem) returned in the set includes all of its
        child information including: all of its
        [CatalogItemVariation](entity:CatalogItemVariation) objects, references to
        its [CatalogModifierList](entity:CatalogModifierList) objects, and the ids of
        any [CatalogTax](entity:CatalogTax) objects that apply to it.

        Parameters
        ----------
        object_ids : typing.Sequence[str]
            The IDs of the CatalogObjects to be retrieved.

        include_related_objects : typing.Optional[bool]
            If `true`, the response will include additional objects that are related to the
            requested objects. Related objects are defined as any objects referenced by ID by the results in the `objects` field
            of the response. These objects are put in the `related_objects` field. Setting this to `true` is
            helpful when the objects are needed for immediate display to a user.
            This process only goes one level deep. Objects referenced by the related objects will not be included. For example,

            if the `objects` field of the response contains a CatalogItem, its associated
            CatalogCategory objects, CatalogTax objects, CatalogImage objects and
            CatalogModifierLists will be returned in the `related_objects` field of the
            response. If the `objects` field of the response contains a CatalogItemVariation,
            its parent CatalogItem will be returned in the `related_objects` field of
            the response.

            Default value: `false`

        catalog_version : typing.Optional[int]
            The specific version of the catalog objects to be included in the response.
            This allows you to retrieve historical versions of objects. The specified version value is matched against
            the [CatalogObject](entity:CatalogObject)s' `version` attribute. If not included, results will
            be from the current version of the catalog.

        include_deleted_objects : typing.Optional[bool]
            Indicates whether to include (`true`) or not (`false`) in the response deleted objects, namely, those with the `is_deleted` attribute set to `true`.

        include_category_path_to_root : typing.Optional[bool]
            Specifies whether or not to include the `path_to_root` list for each returned category instance. The `path_to_root` list consists
            of `CategoryPathToRootNode` objects and specifies the path that starts with the immediate parent category of the returned category
            and ends with its root category. If the returned category is a top-level category, the `path_to_root` list is empty and is not returned
            in the response payload.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchGetCatalogObjectsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/batch-retrieve",
            method="POST",
            json={
                "object_ids": object_ids,
                "include_related_objects": include_related_objects,
                "catalog_version": catalog_version,
                "include_deleted_objects": include_deleted_objects,
                "include_category_path_to_root": include_category_path_to_root,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchGetCatalogObjectsResponse,
                    construct_type(
                        type_=BatchGetCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def batch_upsert(
        self,
        *,
        idempotency_key: str,
        batches: typing.Sequence[CatalogObjectBatchParams],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchUpsertCatalogObjectsResponse]:
        """
        Creates or updates up to 10,000 target objects based on the provided
        list of objects. The target objects are grouped into batches and each batch is
        inserted/updated in an all-or-nothing manner. If an object within a batch is
        malformed in some way, or violates a database constraint, the entire batch
        containing that item will be disregarded. However, other batches in the same
        request may still succeed. Each batch may contain up to 1,000 objects, and
        batches will be processed in order as long as the total object count for the
        request (items, variations, modifier lists, discounts, and taxes) is no more
        than 10,000.

        To ensure consistency, only one update request is processed at a time per seller account.
        While one (batch or non-batch) update request is being processed, other (batched and non-batched)
        update requests are rejected with the `429` error code.

        Parameters
        ----------
        idempotency_key : str
            A value you specify that uniquely identifies this
            request among all your requests. A common way to create
            a valid idempotency key is to use a Universally unique
            identifier (UUID).

            If you're unsure whether a particular request was successful,
            you can reattempt it with the same idempotency key without
            worrying about creating duplicate objects.

            See [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency) for more information.

        batches : typing.Sequence[CatalogObjectBatchParams]
            A batch of CatalogObjects to be inserted/updated atomically.
            The objects within a batch will be inserted in an all-or-nothing fashion, i.e., if an error occurs
            attempting to insert or update an object within a batch, the entire batch will be rejected. However, an error
            in one batch will not affect other batches within the same request.

            For each object, its `updated_at` field is ignored and replaced with a current [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates), and its
            `is_deleted` field must not be set to `true`.

            To modify an existing object, supply its ID. To create a new object, use an ID starting
            with `#`. These IDs may be used to create relationships between an object and attributes of
            other objects that reference it. For example, you can create a CatalogItem with
            ID `#ABC` and a CatalogItemVariation with its `item_id` attribute set to
            `#ABC` in order to associate the CatalogItemVariation with its parent
            CatalogItem.

            Any `#`-prefixed IDs are valid only within a single atomic batch, and will be replaced by server-generated IDs.

            Each batch may contain up to 1,000 objects. The total number of objects across all batches for a single request
            may not exceed 10,000. If either of these limits is violated, an error will be returned and no objects will
            be inserted or updated.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchUpsertCatalogObjectsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/batch-upsert",
            method="POST",
            json={
                "idempotency_key": idempotency_key,
                "batches": convert_and_respect_annotation_metadata(
                    object_=batches, annotation=typing.Sequence[CatalogObjectBatchParams], direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchUpsertCatalogObjectsResponse,
                    construct_type(
                        type_=BatchUpsertCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def info(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CatalogInfoResponse]:
        """
        Retrieves information about the Square Catalog API, such as batch size
        limits that can be used by the `BatchUpsertCatalogObjects` endpoint.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CatalogInfoResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/info",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CatalogInfoResponse,
                    construct_type(
                        type_=CatalogInfoResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def list(
        self,
        *,
        cursor: typing.Optional[str] = None,
        types: typing.Optional[str] = None,
        catalog_version: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[CatalogObject]:
        """
        Returns a list of all [CatalogObject](entity:CatalogObject)s of the specified types in the catalog.

        The `types` parameter is specified as a comma-separated list of the [CatalogObjectType](entity:CatalogObjectType) values,
        for example, "`ITEM`, `ITEM_VARIATION`, `MODIFIER`, `MODIFIER_LIST`, `CATEGORY`, `DISCOUNT`, `TAX`, `IMAGE`".

        __Important:__ ListCatalog does not return deleted catalog items. To retrieve
        deleted catalog items, use [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects)
        and set the `include_deleted_objects` attribute value to `true`.

        Parameters
        ----------
        cursor : typing.Optional[str]
            The pagination cursor returned in the previous response. Leave unset for an initial request.
            The page size is currently set to be 100.
            See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.

        types : typing.Optional[str]
            An optional case-insensitive, comma-separated list of object types to retrieve.

            The valid values are defined in the [CatalogObjectType](entity:CatalogObjectType) enum, for example,
            `ITEM`, `ITEM_VARIATION`, `CATEGORY`, `DISCOUNT`, `TAX`,
            `MODIFIER`, `MODIFIER_LIST`, `IMAGE`, etc.

            If this is unspecified, the operation returns objects of all the top level types at the version
            of the Square API used to make the request. Object types that are nested onto other object types
            are not included in the defaults.

            At the current API version the default object types are:
            ITEM, CATEGORY, TAX, DISCOUNT, MODIFIER_LIST,
            PRICING_RULE, PRODUCT_SET, TIME_PERIOD, MEASUREMENT_UNIT,
            SUBSCRIPTION_PLAN, ITEM_OPTION, CUSTOM_ATTRIBUTE_DEFINITION, QUICK_AMOUNT_SETTINGS.

        catalog_version : typing.Optional[int]
            The specific version of the catalog objects to be included in the response.
            This allows you to retrieve historical versions of objects. The specified version value is matched against
            the [CatalogObject](entity:CatalogObject)s' `version` attribute.  If not included, results will be from the
            current version of the catalog.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[CatalogObject]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/list",
            method="GET",
            params={
                "cursor": cursor,
                "types": types,
                "catalog_version": catalog_version,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _parsed_response = typing.cast(
                    ListCatalogResponse,
                    construct_type(
                        type_=ListCatalogResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                _items = _parsed_response.objects
                _parsed_next = _parsed_response.cursor
                _has_next = _parsed_next is not None and _parsed_next != ""

                async def _get_next():
                    return await self.list(
                        cursor=_parsed_next,
                        types=types,
                        catalog_version=catalog_version,
                        request_options=request_options,
                    )

                return AsyncPager(
                    has_next=_has_next, items=_items, get_next=_get_next, response=BaseHttpResponse(response=_response)
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search(
        self,
        *,
        cursor: typing.Optional[str] = OMIT,
        object_types: typing.Optional[typing.Sequence[CatalogObjectType]] = OMIT,
        include_deleted_objects: typing.Optional[bool] = OMIT,
        include_related_objects: typing.Optional[bool] = OMIT,
        begin_time: typing.Optional[str] = OMIT,
        query: typing.Optional[CatalogQueryParams] = OMIT,
        limit: typing.Optional[int] = OMIT,
        include_category_path_to_root: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SearchCatalogObjectsResponse]:
        """
        Searches for [CatalogObject](entity:CatalogObject) of any type by matching supported search attribute values,
        excluding custom attribute values on items or item variations, against one or more of the specified query filters.

        This (`SearchCatalogObjects`) endpoint differs from the [SearchCatalogItems](api-endpoint:Catalog-SearchCatalogItems)
        endpoint in the following aspects:

        - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects.
        - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not.
        - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does.
        - The both endpoints have different call conventions, including the query filter formats.

        Parameters
        ----------
        cursor : typing.Optional[str]
            The pagination cursor returned in the previous response. Leave unset for an initial request.
            See [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination) for more information.

        object_types : typing.Optional[typing.Sequence[CatalogObjectType]]
            The desired set of object types to appear in the search results.

            If this is unspecified, the operation returns objects of all the top level types at the version
            of the Square API used to make the request. Object types that are nested onto other object types
            are not included in the defaults.

            At the current API version the default object types are:
            ITEM, CATEGORY, TAX, DISCOUNT, MODIFIER_LIST,
            PRICING_RULE, PRODUCT_SET, TIME_PERIOD, MEASUREMENT_UNIT,
            SUBSCRIPTION_PLAN, ITEM_OPTION, CUSTOM_ATTRIBUTE_DEFINITION, QUICK_AMOUNT_SETTINGS.

            Note that if you wish for the query to return objects belonging to nested types (i.e., COMPONENT, IMAGE,
            ITEM_OPTION_VAL, ITEM_VARIATION, or MODIFIER), you must explicitly include all the types of interest
            in this field.

        include_deleted_objects : typing.Optional[bool]
            If `true`, deleted objects will be included in the results. Defaults to `false`. Deleted objects will have their `is_deleted` field set to `true`. If `include_deleted_objects` is `true`, then the `include_category_path_to_root` request parameter must be `false`. Both properties cannot be `true` at the same time.

        include_related_objects : typing.Optional[bool]
            If `true`, the response will include additional objects that are related to the
            requested objects. Related objects are objects that are referenced by object ID by the objects
            in the response. This is helpful if the objects are being fetched for immediate display to a user.
            This process only goes one level deep. Objects referenced by the related objects will not be included.
            For example:

            If the `objects` field of the response contains a CatalogItem, its associated
            CatalogCategory objects, CatalogTax objects, CatalogImage objects and
            CatalogModifierLists will be returned in the `related_objects` field of the
            response. If the `objects` field of the response contains a CatalogItemVariation,
            its parent CatalogItem will be returned in the `related_objects` field of
            the response.

            Default value: `false`

        begin_time : typing.Optional[str]
            Return objects modified after this [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates), in RFC 3339
            format, e.g., `2016-09-04T23:59:33.123Z`. The timestamp is exclusive - objects with a
            timestamp equal to `begin_time` will not be included in the response.

        query : typing.Optional[CatalogQueryParams]
            A query to be used to filter or sort the results. If no query is specified, the entire catalog will be returned.

        limit : typing.Optional[int]
            A limit on the number of results to be returned in a single page. The limit is advisory -
            the implementation may return more or fewer results. If the supplied limit is negative, zero, or
            is higher than the maximum limit of 1,000, it will be ignored.

        include_category_path_to_root : typing.Optional[bool]
            Specifies whether or not to include the `path_to_root` list for each returned category instance. The `path_to_root` list consists of `CategoryPathToRootNode` objects and specifies the path that starts with the immediate parent category of the returned category and ends with its root category. If the returned category is a top-level category, the `path_to_root` list is empty and is not returned in the response payload. If `include_category_path_to_root` is `true`, then the `include_deleted_objects` request parameter must be `false`. Both properties cannot be `true` at the same time.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SearchCatalogObjectsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/search",
            method="POST",
            json={
                "cursor": cursor,
                "object_types": object_types,
                "include_deleted_objects": include_deleted_objects,
                "include_related_objects": include_related_objects,
                "begin_time": begin_time,
                "query": convert_and_respect_annotation_metadata(
                    object_=query, annotation=CatalogQueryParams, direction="write"
                ),
                "limit": limit,
                "include_category_path_to_root": include_category_path_to_root,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchCatalogObjectsResponse,
                    construct_type(
                        type_=SearchCatalogObjectsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def search_items(
        self,
        *,
        text_filter: typing.Optional[str] = OMIT,
        category_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        stock_levels: typing.Optional[typing.Sequence[SearchCatalogItemsRequestStockLevel]] = OMIT,
        enabled_location_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        cursor: typing.Optional[str] = OMIT,
        limit: typing.Optional[int] = OMIT,
        sort_order: typing.Optional[SortOrder] = OMIT,
        product_types: typing.Optional[typing.Sequence[CatalogItemProductType]] = OMIT,
        custom_attribute_filters: typing.Optional[typing.Sequence[CustomAttributeFilterParams]] = OMIT,
        archived_state: typing.Optional[ArchivedState] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SearchCatalogItemsResponse]:
        """
        Searches for catalog items or item variations by matching supported search attribute values, including
        custom attribute values, against one or more of the specified query filters.

        This (`SearchCatalogItems`) endpoint differs from the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects)
        endpoint in the following aspects:

        - `SearchCatalogItems` can only search for items or item variations, whereas `SearchCatalogObjects` can search for any type of catalog objects.
        - `SearchCatalogItems` supports the custom attribute query filters to return items or item variations that contain custom attribute values, where `SearchCatalogObjects` does not.
        - `SearchCatalogItems` does not support the `include_deleted_objects` filter to search for deleted items or item variations, whereas `SearchCatalogObjects` does.
        - The both endpoints use different call conventions, including the query filter formats.

        Parameters
        ----------
        text_filter : typing.Optional[str]
            The text filter expression to return items or item variations containing specified text in
            the `name`, `description`, or `abbreviation` attribute value of an item, or in
            the `name`, `sku`, or `upc` attribute value of an item variation.

        category_ids : typing.Optional[typing.Sequence[str]]
            The category id query expression to return items containing the specified category IDs.

        stock_levels : typing.Optional[typing.Sequence[SearchCatalogItemsRequestStockLevel]]
            The stock-level query expression to return item variations with the specified stock levels.
            See [SearchCatalogItemsRequestStockLevel](#type-searchcatalogitemsrequeststocklevel) for possible values

        enabled_location_ids : typing.Optional[typing.Sequence[str]]
            The enabled-location query expression to return items and item variations having specified enabled locations.

        cursor : typing.Optional[str]
            The pagination token, returned in the previous response, used to fetch the next batch of pending results.

        limit : typing.Optional[int]
            The maximum number of results to return per page. The default value is 100.

        sort_order : typing.Optional[SortOrder]
            The order to sort the results by item names. The default sort order is ascending (`ASC`).
            See [SortOrder](#type-sortorder) for possible values

        product_types : typing.Optional[typing.Sequence[CatalogItemProductType]]
            The product types query expression to return items or item variations having the specified product types.

        custom_attribute_filters : typing.Optional[typing.Sequence[CustomAttributeFilterParams]]
            The customer-attribute filter to return items or item variations matching the specified
            custom attribute expressions. A maximum number of 10 custom attribute expressions are supported in
            a single call to the [SearchCatalogItems](api-endpoint:Catalog-SearchCatalogItems) endpoint.

        archived_state : typing.Optional[ArchivedState]
            The query filter to return not archived (`ARCHIVED_STATE_NOT_ARCHIVED`), archived (`ARCHIVED_STATE_ARCHIVED`), or either type (`ARCHIVED_STATE_ALL`) of items.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SearchCatalogItemsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/search-catalog-items",
            method="POST",
            json={
                "text_filter": text_filter,
                "category_ids": category_ids,
                "stock_levels": stock_levels,
                "enabled_location_ids": enabled_location_ids,
                "cursor": cursor,
                "limit": limit,
                "sort_order": sort_order,
                "product_types": product_types,
                "custom_attribute_filters": convert_and_respect_annotation_metadata(
                    object_=custom_attribute_filters,
                    annotation=typing.Sequence[CustomAttributeFilterParams],
                    direction="write",
                ),
                "archived_state": archived_state,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchCatalogItemsResponse,
                    construct_type(
                        type_=SearchCatalogItemsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_item_modifier_lists(
        self,
        *,
        item_ids: typing.Sequence[str],
        modifier_lists_to_enable: typing.Optional[typing.Sequence[str]] = OMIT,
        modifier_lists_to_disable: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateItemModifierListsResponse]:
        """
        Updates the [CatalogModifierList](entity:CatalogModifierList) objects
        that apply to the targeted [CatalogItem](entity:CatalogItem) without having
        to perform an upsert on the entire item.

        Parameters
        ----------
        item_ids : typing.Sequence[str]
            The IDs of the catalog items associated with the CatalogModifierList objects being updated.

        modifier_lists_to_enable : typing.Optional[typing.Sequence[str]]
            The IDs of the CatalogModifierList objects to enable for the CatalogItem.
            At least one of `modifier_lists_to_enable` or `modifier_lists_to_disable` must be specified.

        modifier_lists_to_disable : typing.Optional[typing.Sequence[str]]
            The IDs of the CatalogModifierList objects to disable for the CatalogItem.
            At least one of `modifier_lists_to_enable` or `modifier_lists_to_disable` must be specified.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateItemModifierListsResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/update-item-modifier-lists",
            method="POST",
            json={
                "item_ids": item_ids,
                "modifier_lists_to_enable": modifier_lists_to_enable,
                "modifier_lists_to_disable": modifier_lists_to_disable,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateItemModifierListsResponse,
                    construct_type(
                        type_=UpdateItemModifierListsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def update_item_taxes(
        self,
        *,
        item_ids: typing.Sequence[str],
        taxes_to_enable: typing.Optional[typing.Sequence[str]] = OMIT,
        taxes_to_disable: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateItemTaxesResponse]:
        """
        Updates the [CatalogTax](entity:CatalogTax) objects that apply to the
        targeted [CatalogItem](entity:CatalogItem) without having to perform an
        upsert on the entire item.

        Parameters
        ----------
        item_ids : typing.Sequence[str]
            IDs for the CatalogItems associated with the CatalogTax objects being updated.
            No more than 1,000 IDs may be provided.

        taxes_to_enable : typing.Optional[typing.Sequence[str]]
            IDs of the CatalogTax objects to enable.
            At least one of `taxes_to_enable` or `taxes_to_disable` must be specified.

        taxes_to_disable : typing.Optional[typing.Sequence[str]]
            IDs of the CatalogTax objects to disable.
            At least one of `taxes_to_enable` or `taxes_to_disable` must be specified.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateItemTaxesResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/catalog/update-item-taxes",
            method="POST",
            json={
                "item_ids": item_ids,
                "taxes_to_enable": taxes_to_enable,
                "taxes_to_disable": taxes_to_disable,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateItemTaxesResponse,
                    construct_type(
                        type_=UpdateItemTaxesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
