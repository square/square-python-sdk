# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..requests.order import OrderParams
from ..core.request_options import RequestOptions
from ..core.http_response import HttpResponse
from ..types.create_order_response import CreateOrderResponse
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.unchecked_base_model import construct_type
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.batch_get_orders_response import BatchGetOrdersResponse
from ..requests.order_reward import OrderRewardParams
from ..types.calculate_order_response import CalculateOrderResponse
from ..types.clone_order_response import CloneOrderResponse
from ..requests.search_orders_query import SearchOrdersQueryParams
from ..types.search_orders_response import SearchOrdersResponse
from ..types.get_order_response import GetOrderResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..types.update_order_response import UpdateOrderResponse
from ..types.pay_order_response import PayOrderResponse
from ..core.client_wrapper import AsyncClientWrapper
from ..core.http_response import AsyncHttpResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawOrdersClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create(
        self,
        *,
        order: typing.Optional[OrderParams] = OMIT,
        idempotency_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreateOrderResponse]:
        """
        Creates a new [order](entity:Order) that can include information about products for
        purchase and settings to apply to the purchase.

        To pay for a created order, see
        [Pay for Orders](https://developer.squareup.com/docs/orders-api/pay-for-orders).

        You can modify open orders using the [UpdateOrder](api-endpoint:Orders-UpdateOrder) endpoint.

        Parameters
        ----------
        order : typing.Optional[OrderParams]
            The order to create. If this field is set, the only other top-level field that can be
            set is the `idempotency_key`.

        idempotency_key : typing.Optional[str]
            A value you specify that uniquely identifies this
            order among orders you have created.

            If you are unsure whether a particular order was created successfully,
            you can try it again with the same idempotency key without
            worrying about creating duplicate orders.

            For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateOrderResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/orders",
            method="POST",
            json={
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=OrderParams, direction="write"
                ),
                "idempotency_key": idempotency_key,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateOrderResponse,
                    construct_type(
                        type_=CreateOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def batch_get(
        self,
        *,
        order_ids: typing.Sequence[str],
        location_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[BatchGetOrdersResponse]:
        """
        Retrieves a set of [orders](entity:Order) by their IDs.

        If a given order ID does not exist, the ID is ignored instead of generating an error.

        Parameters
        ----------
        order_ids : typing.Sequence[str]
            The IDs of the orders to retrieve. A maximum of 100 orders can be retrieved per request.

        location_id : typing.Optional[str]
            The ID of the location for these orders. This field is optional: omit it to retrieve
            orders within the scope of the current authorization's merchant ID.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[BatchGetOrdersResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/orders/batch-retrieve",
            method="POST",
            json={
                "location_id": location_id,
                "order_ids": order_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchGetOrdersResponse,
                    construct_type(
                        type_=BatchGetOrdersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def calculate(
        self,
        *,
        order: OrderParams,
        proposed_rewards: typing.Optional[typing.Sequence[OrderRewardParams]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CalculateOrderResponse]:
        """
        Enables applications to preview order pricing without creating an order.

        Parameters
        ----------
        order : OrderParams
            The order to be calculated. Expects the entire order, not a sparse update.

        proposed_rewards : typing.Optional[typing.Sequence[OrderRewardParams]]
            Identifies one or more loyalty reward tiers to apply during the order calculation.
            The discounts defined by the reward tiers are added to the order only to preview the
            effect of applying the specified rewards. The rewards do not correspond to actual
            redemptions; that is, no `reward`s are created. Therefore, the reward `id`s are
            random strings used only to reference the reward tier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CalculateOrderResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/orders/calculate",
            method="POST",
            json={
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=OrderParams, direction="write"
                ),
                "proposed_rewards": convert_and_respect_annotation_metadata(
                    object_=proposed_rewards,
                    annotation=typing.Optional[typing.Sequence[OrderRewardParams]],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CalculateOrderResponse,
                    construct_type(
                        type_=CalculateOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def clone(
        self,
        *,
        order_id: str,
        version: typing.Optional[int] = OMIT,
        idempotency_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CloneOrderResponse]:
        """
        Creates a new order, in the `DRAFT` state, by duplicating an existing order. The newly created order has
        only the core fields (such as line items, taxes, and discounts) copied from the original order.

        Parameters
        ----------
        order_id : str
            The ID of the order to clone.

        version : typing.Optional[int]
            An optional order version for concurrency protection.

            If a version is provided, it must match the latest stored version of the order to clone.
            If a version is not provided, the API clones the latest version.

        idempotency_key : typing.Optional[str]
            A value you specify that uniquely identifies this clone request.

            If you are unsure whether a particular order was cloned successfully,
            you can reattempt the call with the same idempotency key without
            worrying about creating duplicate cloned orders.
            The originally cloned order is returned.

            For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CloneOrderResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/orders/clone",
            method="POST",
            json={
                "order_id": order_id,
                "version": version,
                "idempotency_key": idempotency_key,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CloneOrderResponse,
                    construct_type(
                        type_=CloneOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def search(
        self,
        *,
        location_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        cursor: typing.Optional[str] = OMIT,
        query: typing.Optional[SearchOrdersQueryParams] = OMIT,
        limit: typing.Optional[int] = OMIT,
        return_entries: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SearchOrdersResponse]:
        """
        Search all orders for one or more locations. Orders include all sales,
        returns, and exchanges regardless of how or when they entered the Square
        ecosystem (such as Point of Sale, Invoices, and Connect APIs).

        `SearchOrders` requests need to specify which locations to search and define a
        [SearchOrdersQuery](entity:SearchOrdersQuery) object that controls
        how to sort or filter the results. Your `SearchOrdersQuery` can:

          Set filter criteria.
          Set the sort order.
          Determine whether to return results as complete `Order` objects or as
        [OrderEntry](entity:OrderEntry) objects.

        Note that details for orders processed with Square Point of Sale while in
        offline mode might not be transmitted to Square for up to 72 hours. Offline
        orders have a `created_at` value that reflects the time the order was created,
        not the time it was subsequently transmitted to Square.

        Parameters
        ----------
        location_ids : typing.Optional[typing.Sequence[str]]
            The location IDs for the orders to query. All locations must belong to
            the same merchant.

            Max: 10 location IDs.

        cursor : typing.Optional[str]
            A pagination cursor returned by a previous call to this endpoint.
            Provide this cursor to retrieve the next set of results for your original query.
            For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).

        query : typing.Optional[SearchOrdersQueryParams]
            Query conditions used to filter or sort the results. Note that when
            retrieving additional pages using a cursor, you must use the original query.

        limit : typing.Optional[int]
            The maximum number of results to be returned in a single page.

            Default: `500`
            Max: `1000`

        return_entries : typing.Optional[bool]
            A Boolean that controls the format of the search results. If `true`,
            `SearchOrders` returns [OrderEntry](entity:OrderEntry) objects. If `false`, `SearchOrders`
            returns complete order objects.

            Default: `false`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SearchOrdersResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/orders/search",
            method="POST",
            json={
                "location_ids": location_ids,
                "cursor": cursor,
                "query": convert_and_respect_annotation_metadata(
                    object_=query, annotation=SearchOrdersQueryParams, direction="write"
                ),
                "limit": limit,
                "return_entries": return_entries,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchOrdersResponse,
                    construct_type(
                        type_=SearchOrdersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, order_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetOrderResponse]:
        """
        Retrieves an [Order](entity:Order) by ID.

        Parameters
        ----------
        order_id : str
            The ID of the order to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetOrderResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/orders/{jsonable_encoder(order_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetOrderResponse,
                    construct_type(
                        type_=GetOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        order_id: str,
        *,
        order: typing.Optional[OrderParams] = OMIT,
        fields_to_clear: typing.Optional[typing.Sequence[str]] = OMIT,
        idempotency_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdateOrderResponse]:
        """
        Updates an open [order](entity:Order) by adding, replacing, or deleting
        fields. Orders with a `COMPLETED` or `CANCELED` state cannot be updated.

        An `UpdateOrder` request requires the following:

        - The `order_id` in the endpoint path, identifying the order to update.
        - The latest `version` of the order to update.
        - The [sparse order](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#sparse-order-objects)
        containing only the fields to update and the version to which the update is
        being applied.
        - If deleting fields, the [dot notation paths](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#identifying-fields-to-delete)
        identifying the fields to clear.

        To pay for an order, see
        [Pay for Orders](https://developer.squareup.com/docs/orders-api/pay-for-orders).

        Parameters
        ----------
        order_id : str
            The ID of the order to update.

        order : typing.Optional[OrderParams]
            The [sparse order](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#sparse-order-objects)
            containing only the fields to update and the version to which the update is
            being applied.

        fields_to_clear : typing.Optional[typing.Sequence[str]]
            The [dot notation paths](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#identifying-fields-to-delete)
            fields to clear. For example, `line_items[uid].note`.
            For more information, see [Deleting fields](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#deleting-fields).

        idempotency_key : typing.Optional[str]
            A value you specify that uniquely identifies this update request.

            If you are unsure whether a particular update was applied to an order successfully,
            you can reattempt it with the same idempotency key without
            worrying about creating duplicate updates to the order.
            The latest order version is returned.

            For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdateOrderResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/orders/{jsonable_encoder(order_id)}",
            method="PUT",
            json={
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=OrderParams, direction="write"
                ),
                "fields_to_clear": fields_to_clear,
                "idempotency_key": idempotency_key,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateOrderResponse,
                    construct_type(
                        type_=UpdateOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def pay(
        self,
        order_id: str,
        *,
        idempotency_key: str,
        order_version: typing.Optional[int] = OMIT,
        payment_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[PayOrderResponse]:
        """
        Pay for an [order](entity:Order) using one or more approved [payments](entity:Payment)
        or settle an order with a total of `0`.

        The total of the `payment_ids` listed in the request must be equal to the order
        total. Orders with a total amount of `0` can be marked as paid by specifying an empty
        array of `payment_ids` in the request.

        To be used with `PayOrder`, a payment must:

        - Reference the order by specifying the `order_id` when [creating the payment](api-endpoint:Payments-CreatePayment).
        Any approved payments that reference the same `order_id` not specified in the
        `payment_ids` is canceled.
        - Be approved with [delayed capture](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/delayed-capture).
        Using a delayed capture payment with `PayOrder` completes the approved payment.

        Parameters
        ----------
        order_id : str
            The ID of the order being paid.

        idempotency_key : str
            A value you specify that uniquely identifies this request among requests you have sent. If
            you are unsure whether a particular payment request was completed successfully, you can reattempt
            it with the same idempotency key without worrying about duplicate payments.

            For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).

        order_version : typing.Optional[int]
            The version of the order being paid. If not supplied, the latest version will be paid.

        payment_ids : typing.Optional[typing.Sequence[str]]
            The IDs of the [payments](entity:Payment) to collect.
            The payment total must match the order total.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[PayOrderResponse]
            Success
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/orders/{jsonable_encoder(order_id)}/pay",
            method="POST",
            json={
                "idempotency_key": idempotency_key,
                "order_version": order_version,
                "payment_ids": payment_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PayOrderResponse,
                    construct_type(
                        type_=PayOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawOrdersClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create(
        self,
        *,
        order: typing.Optional[OrderParams] = OMIT,
        idempotency_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreateOrderResponse]:
        """
        Creates a new [order](entity:Order) that can include information about products for
        purchase and settings to apply to the purchase.

        To pay for a created order, see
        [Pay for Orders](https://developer.squareup.com/docs/orders-api/pay-for-orders).

        You can modify open orders using the [UpdateOrder](api-endpoint:Orders-UpdateOrder) endpoint.

        Parameters
        ----------
        order : typing.Optional[OrderParams]
            The order to create. If this field is set, the only other top-level field that can be
            set is the `idempotency_key`.

        idempotency_key : typing.Optional[str]
            A value you specify that uniquely identifies this
            order among orders you have created.

            If you are unsure whether a particular order was created successfully,
            you can try it again with the same idempotency key without
            worrying about creating duplicate orders.

            For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateOrderResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/orders",
            method="POST",
            json={
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=OrderParams, direction="write"
                ),
                "idempotency_key": idempotency_key,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateOrderResponse,
                    construct_type(
                        type_=CreateOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def batch_get(
        self,
        *,
        order_ids: typing.Sequence[str],
        location_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[BatchGetOrdersResponse]:
        """
        Retrieves a set of [orders](entity:Order) by their IDs.

        If a given order ID does not exist, the ID is ignored instead of generating an error.

        Parameters
        ----------
        order_ids : typing.Sequence[str]
            The IDs of the orders to retrieve. A maximum of 100 orders can be retrieved per request.

        location_id : typing.Optional[str]
            The ID of the location for these orders. This field is optional: omit it to retrieve
            orders within the scope of the current authorization's merchant ID.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[BatchGetOrdersResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/orders/batch-retrieve",
            method="POST",
            json={
                "location_id": location_id,
                "order_ids": order_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    BatchGetOrdersResponse,
                    construct_type(
                        type_=BatchGetOrdersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def calculate(
        self,
        *,
        order: OrderParams,
        proposed_rewards: typing.Optional[typing.Sequence[OrderRewardParams]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CalculateOrderResponse]:
        """
        Enables applications to preview order pricing without creating an order.

        Parameters
        ----------
        order : OrderParams
            The order to be calculated. Expects the entire order, not a sparse update.

        proposed_rewards : typing.Optional[typing.Sequence[OrderRewardParams]]
            Identifies one or more loyalty reward tiers to apply during the order calculation.
            The discounts defined by the reward tiers are added to the order only to preview the
            effect of applying the specified rewards. The rewards do not correspond to actual
            redemptions; that is, no `reward`s are created. Therefore, the reward `id`s are
            random strings used only to reference the reward tier.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CalculateOrderResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/orders/calculate",
            method="POST",
            json={
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=OrderParams, direction="write"
                ),
                "proposed_rewards": convert_and_respect_annotation_metadata(
                    object_=proposed_rewards,
                    annotation=typing.Optional[typing.Sequence[OrderRewardParams]],
                    direction="write",
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CalculateOrderResponse,
                    construct_type(
                        type_=CalculateOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def clone(
        self,
        *,
        order_id: str,
        version: typing.Optional[int] = OMIT,
        idempotency_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CloneOrderResponse]:
        """
        Creates a new order, in the `DRAFT` state, by duplicating an existing order. The newly created order has
        only the core fields (such as line items, taxes, and discounts) copied from the original order.

        Parameters
        ----------
        order_id : str
            The ID of the order to clone.

        version : typing.Optional[int]
            An optional order version for concurrency protection.

            If a version is provided, it must match the latest stored version of the order to clone.
            If a version is not provided, the API clones the latest version.

        idempotency_key : typing.Optional[str]
            A value you specify that uniquely identifies this clone request.

            If you are unsure whether a particular order was cloned successfully,
            you can reattempt the call with the same idempotency key without
            worrying about creating duplicate cloned orders.
            The originally cloned order is returned.

            For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CloneOrderResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/orders/clone",
            method="POST",
            json={
                "order_id": order_id,
                "version": version,
                "idempotency_key": idempotency_key,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CloneOrderResponse,
                    construct_type(
                        type_=CloneOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def search(
        self,
        *,
        location_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        cursor: typing.Optional[str] = OMIT,
        query: typing.Optional[SearchOrdersQueryParams] = OMIT,
        limit: typing.Optional[int] = OMIT,
        return_entries: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SearchOrdersResponse]:
        """
        Search all orders for one or more locations. Orders include all sales,
        returns, and exchanges regardless of how or when they entered the Square
        ecosystem (such as Point of Sale, Invoices, and Connect APIs).

        `SearchOrders` requests need to specify which locations to search and define a
        [SearchOrdersQuery](entity:SearchOrdersQuery) object that controls
        how to sort or filter the results. Your `SearchOrdersQuery` can:

          Set filter criteria.
          Set the sort order.
          Determine whether to return results as complete `Order` objects or as
        [OrderEntry](entity:OrderEntry) objects.

        Note that details for orders processed with Square Point of Sale while in
        offline mode might not be transmitted to Square for up to 72 hours. Offline
        orders have a `created_at` value that reflects the time the order was created,
        not the time it was subsequently transmitted to Square.

        Parameters
        ----------
        location_ids : typing.Optional[typing.Sequence[str]]
            The location IDs for the orders to query. All locations must belong to
            the same merchant.

            Max: 10 location IDs.

        cursor : typing.Optional[str]
            A pagination cursor returned by a previous call to this endpoint.
            Provide this cursor to retrieve the next set of results for your original query.
            For more information, see [Pagination](https://developer.squareup.com/docs/build-basics/common-api-patterns/pagination).

        query : typing.Optional[SearchOrdersQueryParams]
            Query conditions used to filter or sort the results. Note that when
            retrieving additional pages using a cursor, you must use the original query.

        limit : typing.Optional[int]
            The maximum number of results to be returned in a single page.

            Default: `500`
            Max: `1000`

        return_entries : typing.Optional[bool]
            A Boolean that controls the format of the search results. If `true`,
            `SearchOrders` returns [OrderEntry](entity:OrderEntry) objects. If `false`, `SearchOrders`
            returns complete order objects.

            Default: `false`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SearchOrdersResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/orders/search",
            method="POST",
            json={
                "location_ids": location_ids,
                "cursor": cursor,
                "query": convert_and_respect_annotation_metadata(
                    object_=query, annotation=SearchOrdersQueryParams, direction="write"
                ),
                "limit": limit,
                "return_entries": return_entries,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SearchOrdersResponse,
                    construct_type(
                        type_=SearchOrdersResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, order_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetOrderResponse]:
        """
        Retrieves an [Order](entity:Order) by ID.

        Parameters
        ----------
        order_id : str
            The ID of the order to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetOrderResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/orders/{jsonable_encoder(order_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetOrderResponse,
                    construct_type(
                        type_=GetOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        order_id: str,
        *,
        order: typing.Optional[OrderParams] = OMIT,
        fields_to_clear: typing.Optional[typing.Sequence[str]] = OMIT,
        idempotency_key: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdateOrderResponse]:
        """
        Updates an open [order](entity:Order) by adding, replacing, or deleting
        fields. Orders with a `COMPLETED` or `CANCELED` state cannot be updated.

        An `UpdateOrder` request requires the following:

        - The `order_id` in the endpoint path, identifying the order to update.
        - The latest `version` of the order to update.
        - The [sparse order](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#sparse-order-objects)
        containing only the fields to update and the version to which the update is
        being applied.
        - If deleting fields, the [dot notation paths](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#identifying-fields-to-delete)
        identifying the fields to clear.

        To pay for an order, see
        [Pay for Orders](https://developer.squareup.com/docs/orders-api/pay-for-orders).

        Parameters
        ----------
        order_id : str
            The ID of the order to update.

        order : typing.Optional[OrderParams]
            The [sparse order](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#sparse-order-objects)
            containing only the fields to update and the version to which the update is
            being applied.

        fields_to_clear : typing.Optional[typing.Sequence[str]]
            The [dot notation paths](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#identifying-fields-to-delete)
            fields to clear. For example, `line_items[uid].note`.
            For more information, see [Deleting fields](https://developer.squareup.com/docs/orders-api/manage-orders/update-orders#deleting-fields).

        idempotency_key : typing.Optional[str]
            A value you specify that uniquely identifies this update request.

            If you are unsure whether a particular update was applied to an order successfully,
            you can reattempt it with the same idempotency key without
            worrying about creating duplicate updates to the order.
            The latest order version is returned.

            For more information, see [Idempotency](https://developer.squareup.com/docs/build-basics/common-api-patterns/idempotency).

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdateOrderResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/orders/{jsonable_encoder(order_id)}",
            method="PUT",
            json={
                "order": convert_and_respect_annotation_metadata(
                    object_=order, annotation=OrderParams, direction="write"
                ),
                "fields_to_clear": fields_to_clear,
                "idempotency_key": idempotency_key,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdateOrderResponse,
                    construct_type(
                        type_=UpdateOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def pay(
        self,
        order_id: str,
        *,
        idempotency_key: str,
        order_version: typing.Optional[int] = OMIT,
        payment_ids: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[PayOrderResponse]:
        """
        Pay for an [order](entity:Order) using one or more approved [payments](entity:Payment)
        or settle an order with a total of `0`.

        The total of the `payment_ids` listed in the request must be equal to the order
        total. Orders with a total amount of `0` can be marked as paid by specifying an empty
        array of `payment_ids` in the request.

        To be used with `PayOrder`, a payment must:

        - Reference the order by specifying the `order_id` when [creating the payment](api-endpoint:Payments-CreatePayment).
        Any approved payments that reference the same `order_id` not specified in the
        `payment_ids` is canceled.
        - Be approved with [delayed capture](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/delayed-capture).
        Using a delayed capture payment with `PayOrder` completes the approved payment.

        Parameters
        ----------
        order_id : str
            The ID of the order being paid.

        idempotency_key : str
            A value you specify that uniquely identifies this request among requests you have sent. If
            you are unsure whether a particular payment request was completed successfully, you can reattempt
            it with the same idempotency key without worrying about duplicate payments.

            For more information, see [Idempotency](https://developer.squareup.com/docs/working-with-apis/idempotency).

        order_version : typing.Optional[int]
            The version of the order being paid. If not supplied, the latest version will be paid.

        payment_ids : typing.Optional[typing.Sequence[str]]
            The IDs of the [payments](entity:Payment) to collect.
            The payment total must match the order total.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[PayOrderResponse]
            Success
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/orders/{jsonable_encoder(order_id)}/pay",
            method="POST",
            json={
                "idempotency_key": idempotency_key,
                "order_version": order_version,
                "payment_ids": payment_ids,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    PayOrderResponse,
                    construct_type(
                        type_=PayOrderResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
