# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .inventory_state import InventoryState


class InventoryAdjustmentGroup(UncheckedBaseModel):
    id: typing.Optional[str] = pydantic.Field(default=None)
    """
    A unique ID generated by Square for the
    `InventoryAdjustmentGroup`.
    """

    root_adjustment_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    The inventory adjustment of the composed variation.
    """

    from_state: typing.Optional[InventoryState] = pydantic.Field(default=None)
    """
    Representative `from_state` for adjustments within the group. For example, for a group adjustment from `IN_STOCK` to `SOLD`,
    there can be two component adjustments in the group: one from `IN_STOCK`to `COMPOSED` and the other one from `COMPOSED` to `SOLD`.
    Here, the representative `from_state` for the `InventoryAdjustmentGroup` is `IN_STOCK`.
    See [InventoryState](#type-inventorystate) for possible values
    """

    to_state: typing.Optional[InventoryState] = pydantic.Field(default=None)
    """
    Representative `to_state` for adjustments within group. For example, for a group adjustment from `IN_STOCK` to `SOLD`,
    the two component adjustments in the group can be from `IN_STOCK` to `COMPOSED` and from `COMPOSED` to `SOLD`.
    Here, the representative `to_state` of the `InventoryAdjustmentGroup` is `SOLD`.
    See [InventoryState](#type-inventorystate) for possible values
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
