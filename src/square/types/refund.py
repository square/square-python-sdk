# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .additional_recipient import AdditionalRecipient
from .money import Money
from .refund_status import RefundStatus


class Refund(UncheckedBaseModel):
    """
    Represents a refund processed for a Square transaction.
    """

    id: str = pydantic.Field()
    """
    The refund's unique ID.
    """

    location_id: str = pydantic.Field()
    """
    The ID of the refund's associated location.
    """

    transaction_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    The ID of the transaction that the refunded tender is part of.
    """

    tender_id: typing.Optional[str] = pydantic.Field(default=None)
    """
    The ID of the refunded tender.
    """

    created_at: typing.Optional[str] = pydantic.Field(default=None)
    """
    The timestamp for when the refund was created, in RFC 3339 format.
    """

    reason: str = pydantic.Field()
    """
    The reason for the refund being issued.
    """

    amount_money: Money = pydantic.Field()
    """
    The amount of money refunded to the buyer.
    """

    status: RefundStatus = pydantic.Field()
    """
    The current status of the refund (`PENDING`, `APPROVED`, `REJECTED`,
    or `FAILED`).
    See [RefundStatus](#type-refundstatus) for possible values
    """

    processing_fee_money: typing.Optional[Money] = pydantic.Field(default=None)
    """
    The amount of Square processing fee money refunded to the *merchant*.
    """

    additional_recipients: typing.Optional[typing.List[AdditionalRecipient]] = pydantic.Field(default=None)
    """
    Additional recipients (other than the merchant) receiving a portion of this refund.
    For example, fees assessed on a refund of a purchase by a third party integration.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
